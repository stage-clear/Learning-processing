# Chapter 2. 力

1. [力とニュートンの運動の法則](#section-2_1)
2. [力と Processing - 関数としてのニュートンの第２の法則](#section-2_2)
3. [力の積算](#section-2_3)
4. [質量](#section-2_4)
5. [力の作成](#section-2_5)
6. [地球と重力と力のシミュレーション](#section-2_6)
7. [摩擦](#section-2_7)
8. [空気抵抗と流体抵抗](#section-2_8)
9. [重力](#section-2_9)
10. [相互引力と反発](#section-2_10)

## <a id="section-2_1"></a>2.1 力とニュートンの運動の法則
> __力とは__, 質量を持った物体に加速を生じさせる__ベクトルである__

### ニュートンの運動の第1法則
> 静止している物体は静止状態を続け, 運動している物体は運動を続ける

ただし, これには力に関する重要な要素が不足しています.

> 静止している物体は静止状態を続け, 運動している物体は, 不平衡力の影響を受けない限り, 一定の速さで一定の方向に運動を続ける

Processing の世界では, ニュートンの運動の第1法則を次のように言い換えることができます.

> オブジェクトの PVector の速度は, オブジェクトが釣り合った状態にある場合には一定のままである.

### ニュートンの運動の第3法則
> すべての作用には, 大きさが同じで向きが反対の反作用がある

第3法則の記述をもう少しうまく言うと, 次のようになるでしょう.

> 力は必ず対になって発生する. 2つの力の強さは等しく, 向きは反対である

### ニュートンの第３法則 （Processing の観点から）
> オブジェクトAのオブジェクトBに対する力 `PVector f` を計算する場合, 
> オブジェクトAに対するオブジェクトBの力(`PVector.mult(f, -1)`) も適用する必要がある

ただし, Procssing プログラミングの世界では, 常にこの法則通りである必要はありません  
私たちは単に自然世界の物理にヒントを得ているだけであり, すべてを精密にシミュレーションしようというわけではないのです.

## <a id="section-2_2"></a>2.2 力と Processing - 関数としてのニュートンの第2法則
### ニュートンの運動の第2法則
> 質量に加速度（acceleration）を掛けると力になる

すなわち:

```mathematica
F→ = M * A→
```

これが私たちにとって最も重要な法則であるのはなぜでしょうか?
ちょっと書き方を変えてみましょう.

```mathematica
A→ = F→ / M
```

加速度は力に比例し, 質量は反比例します.
つまり, あなたが押された場合, その力が強いほど早く動く（加速する）ということです.
そして, あなたが大きいほど, ゆっくり動きます.

> __重量と質量__
> - 物体の__質量__は, 物体内の物質の量を表します.  
> - __重量__はよく質量と混同されますが, 厳密には物体にかかる重力です.
    ニュートンの第2法則から, 重量は質量 × 重力加速度(w = m * g)として求めることができます.
    重量の単位はニュートン(N)です
> - __密度__は, 単位体積あたりの質量です.  
> 地球上で1キログラムの質量を持つ物体は, 月でも1キログラムの質量を持ちます.
> しかし,その重量は6分の1になります.

Processing の世界で言う質量とはなんでしょうか?
ここでは単純化して, 私たちの仮想のピクセル世界では, すべての物体の質量が1であるとしましょう.
`F / 1 = F` です. つまり:

```mathematica
A→ = F→
```

となり, オブジェクトの加速度は力と等しいということになります.

ここからは, すべての始まりが__力__であることを見ていきます.

位置, 速度, 加速度を持った Mover クラスを使いましょう.

```processing
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
}
```

ここでの目標は, この物体に力を加えることです.
例えば, 次のようにします.

```processing
mover.applyForce(wind);
```

または,

```processing
mover.applyForce(gravity);
```

`wind` と `gravity` は `PVector` です. ニュートンの第2法則により, この関数は次のように実装することができます.

```processing
void applyForce(PVector force) {
  acceleration = force; // 最も単純な形のニュートンの第2法則
}
```

## <a id="section-2_3"></a>2.3 力の積算
`acceleration = force` は, ニュートンの第2法則をそのまま変形したものです（質量を考慮していません）.
しかし, これには大きな問題があります. 私たちの目的を思い出してください.
風と重力に反応する, 画面上を動くオブジェクトを作ることです.

```processing
mover.applyForce(wind);
mover.applyForce(gravity);
mover.update();
mover.display();
```

ここに大きな問題が! 速度に加算されるときの, 加速度の値はなんでしょうか?
`gravity` と同じです. 風が無視されています! `applyForce()` を何回か呼び出すと, 前回の呼び出しが上書きされてしまうのです.
複数の力を扱うにはどうしたらよいでしょうか?

実を言うと, 先ほどのニュートンの第2法則は単純化したものでした.
正確には以下のようになります.

> 質量に加速度を掛けると合力 (net force) になる

つまり, 加速度は__すべての力の合計__を質量で割ったものに等しいということです.  
これを実装するためには, __力の積算__を行います. これはとても単純で, すべての力を合計するだけです.
ある瞬間に存在する力は, 1個かもしれませんし, 2個かもしれません, 6個, 12個, もしくは303個かもしれません.
オブジェクトがこれらの積算方法を認識している限り, 何個の力がはたらいても構いません

```processing
void applyForce(PVector force) {
  acceleration.add(force); // ニュートンの第2法則. ただし力の積算を行うすべての力を加速度に1つずつ加算
}
```

まだ終わりではありません. 力を積算する場合には, もう1つするべきことがあります.
ある瞬間におけるにおけるすべての力を合計しているため, `update()` を呼び出す前に毎回, 加速度をクリアする必要があります.

```processing
if (mousePressed) {
  PVector wind = new PVector(0.5, 0);
  mover.applyForce(wind);
}
```

各フレームで加速をクリアするためには, `update()` の最後で `PVector` に0を掛けると簡単です.

```processing
void update() {
  velocity.add(acceleration);
  location.add(velocity);
  acceleration.mult(0);
}
```

- [ ] __Exercise 2.1__ 
 - 力を使って, ヘリウムが入った風船が浮かび上がり, ウィンドウの上部でバウンドするところをシミュレートしてください.
   パーリンノイズなどを使って, 時間とともに変化する風力を追加してみましょう.

## <a id="section-2_4"></a>2.4 質量
ニュートンの第2法則が `A→ = F→` ではなくて, 実際には `F→ = M * A→` であるということは分かりました.
質量を（_mass_）を組み込むのは簡単で, クラスにインスタンス変数を追加するだけです.

```processing
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float mass; // <- 質量を浮動小数点として追加
}
```

> __計測単位__
> 現実世界では, 何かを計測するときには特定の単位を使います.
> 例えば, 2つの物体の距離は3メートルだ, 今の球速は90マイルだ, このボーリングの球の重さは6キログラムだ, などと言います.
> 私たちの計測単位はピクセルと, アニメーションフレームです. 質量については, 使用する計測単位が存在しません.

質量は物体内の物質の量を示す1つの数値にすぎず, ベクトルではなくスカラーです.
ここでは, 例えばシェイプの面積を質量として扱うこともできますが, もっと簡単に, 
「このオブジェクトの質量は?うーん...10にしておくか!」というところから始めます.

```processing
Mover() {
  location = new PVector(random(width), random(height));
  velocity = new PVector(0, 0);
  acceleration = new PVector(0, 0);
  mass = 10.0;
}
```

それほど面白みはありませんが, はじめのうちは仕方ありませんね.
質量はどこで登場するのでしょうか?
オブジェクトにニュートンの第2法則を適用するところです.

```processing
void applyForce(PVector force) {
  force.div(mass); // ニュートンの第2法則(力の積算と質量を考慮):
  acceleration.add(force);
}
```

これでもよさそうですが, ここにもまた大きな問題があります.
2つのMoverオブジェクトがあり, どちらも風の力で吹き飛ばされる, という設定について考えてみましょう

```processing
Mover m1 = new Mover();
Mover m2 = new Mover();

PVector wind = new PVector(1, 0);

m1.applyForce(wind);
m2.applyForce(wind);
```

オブジェクトの使用に関して, 「オブジェクト（ここでは `PVector`）を関数に渡すとき, 実際に渡しているのはそのオブジェクトの参照である」という格言があります.

```processing
void applyForce(PVector force) {
  PVector f = force.get(); // <- 使用する前に PVector のコピーを作成
  f.div(mass)
  acceleration.add(f);
}
```

static メソッド `div()` を使ってこの関数を使用する方法もあります.

- [x] __Exercise 2.2__ `applyForce()` メソッドを, `get()` の代わりに static メソッド `div()` を使って書き換えてください

```processing
void applyForce(PVector force) {
  PVector f = PVector.div(force, mass)
  acceleration.add(f);
}
```

## <a id="section-2_5"></a>2.5 力の作成



## <a id="section-2_6"></a>2.6
## <a id="section-2_7"></a>2.7
## <a id="section-2_8"></a>2.8
## <a id="section-2_9"></a>2.9
## <a id="section-2_10"></a>2.10
